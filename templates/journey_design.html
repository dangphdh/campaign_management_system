{% extends "layout.html" %}

{% block content %}
<style>
.journey-design-container {
    display: flex;
    height: calc(100vh - 100px);
}

.toolbar {
    width: 250px;
    background: #f5f5f5;
    padding: 20px;
    border-right: 1px solid #ddd;
}

.toolbar-item {
    padding: 10px;
    margin: 5px 0;
    background: white;
    border: 1px solid #ddd;
    border-radius: 4px;
    cursor: move;
    user-select: none;
}

.canvas-container {
    flex-grow: 1;
    position: relative;
    overflow: hidden;
    background: #fafafa;
}

#journeyCanvas {
    position: absolute;
    width: 100%;
    height: 100%;
}

.step-node {
    position: absolute;
    width: 200px;
    padding: 15px;
    background: white;
    border: 1px solid #ddd;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    cursor: move;
    user-select: none;
}

.step-node .handle {
    width: 12px;
    height: 12px;
    background: #666;
    border-radius: 50%;
    position: absolute;
}

.step-node .handle.input {
    top: 50%;
    left: -6px;
    transform: translateY(-50%);
}

.step-node .handle.output {
    top: 50%;
    right: -6px;
    transform: translateY(-50%);
}

.step-node .title {
    font-weight: bold;
    margin-bottom: 8px;
}

.step-node .type {
    font-size: 12px;
    color: #666;
}

.step-node .details {
    margin-top: 8px;
    font-size: 12px;
}

.toolbar-header {
    font-size: 16px;
    font-weight: bold;
    margin-bottom: 15px;
}

.save-button {
    position: absolute;
    bottom: 20px;
    right: 20px;
    padding: 10px 20px;
    background: #007bff;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

.save-button:hover {
    background: #0056b3;
}
</style>

<div class="journey-design-container">
    <div class="toolbar">
        <div class="toolbar-header">Journey Steps</div>
        <div class="toolbar-item" data-type="email">
            <div class="title">Email</div>
            <div class="type">Communication</div>
        </div>
        <div class="toolbar-item" data-type="sms">
            <div class="title">SMS</div>
            <div class="type">Communication</div>
        </div>
        <div class="toolbar-item" data-type="wait">
            <div class="title">Wait</div>
            <div class="type">Delay</div>
        </div>
        <div class="toolbar-item" data-type="condition">
            <div class="title">Condition</div>
            <div class="type">Decision</div>
        </div>
    </div>
    
    <div class="canvas-container">
        <svg id="journeyCanvas"></svg>
        <button class="save-button" id="saveJourney">Save Journey</button>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const canvas = document.getElementById('journeyCanvas');
    const canvasContainer = document.querySelector('.canvas-container');
    let steps = [];
    let connections = [];
    let draggedElement = null;
    let selectedHandle = null;
    let drawingLine = false;
    let tempLine = null;
    let stepCounter = 0;

    // Set canvas size
    function updateCanvasSize() {
        canvas.setAttribute('width', canvasContainer.offsetWidth);
        canvas.setAttribute('height', canvasContainer.offsetHeight);
    }
    updateCanvasSize();
    window.addEventListener('resize', updateCanvasSize);

    // Create a new step node
    function createStepNode(type, x, y) {
        stepCounter++;
        const step = document.createElement('div');
        step.className = 'step-node';
        step.dataset.stepId = `step-${stepCounter}`;
        step.innerHTML = `
            <div class="handle input"></div>
            <div class="title">${type.charAt(0).toUpperCase() + type.slice(1)}</div>
            <div class="type">${type}</div>
            <div class="details">Step ${stepCounter}</div>
            <div class="handle output"></div>
        `;
        step.style.left = `${x}px`;
        step.style.top = `${y}px`;
        
        canvasContainer.appendChild(step);
        steps.push(step);
        
        makeStepDraggable(step);
        setupHandles(step);
        return step;
    }

    // Make step draggable
    function makeStepDraggable(step) {
        let offsetX, offsetY;
        
        step.addEventListener('mousedown', function(e) {
            if (e.target.classList.contains('handle')) return;
            
            offsetX = e.clientX - step.offsetLeft;
            offsetY = e.clientY - step.offsetTop;
            draggedElement = step;
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });

        function onMouseMove(e) {
            if (!draggedElement) return;
            
            const x = e.clientX - offsetX;
            const y = e.clientY - offsetY;
            
            draggedElement.style.left = `${x}px`;
            draggedElement.style.top = `${y}px`;
            
            updateConnections();
        }

        function onMouseUp() {
            draggedElement = null;
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
        }
    }

    // Setup connection handles
    function setupHandles(step) {
        const handles = step.querySelectorAll('.handle');
        
        handles.forEach(handle => {
            handle.addEventListener('mousedown', function(e) {
                e.stopPropagation();
                selectedHandle = handle;
                drawingLine = true;
                
                const rect = handle.getBoundingClientRect();
                const x = rect.left + rect.width / 2 - canvasContainer.offsetLeft;
                const y = rect.top + rect.height / 2 - canvasContainer.offsetTop;
                
                tempLine = createLine(x, y, x, y);
                canvas.appendChild(tempLine);
            });
        });
    }

    // Create SVG line
    function createLine(x1, y1, x2, y2) {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', x1);
        line.setAttribute('y1', y1);
        line.setAttribute('x2', x2);
        line.setAttribute('y2', y2);
        line.setAttribute('stroke', '#666');
        line.setAttribute('stroke-width', '2');
        return line;
    }

    // Update connections
    function updateConnections() {
        connections.forEach(conn => {
            const startRect = conn.start.getBoundingClientRect();
            const endRect = conn.end.getBoundingClientRect();
            
            const x1 = startRect.left + startRect.width / 2 - canvasContainer.offsetLeft;
            const y1 = startRect.top + startRect.height / 2 - canvasContainer.offsetTop;
            const x2 = endRect.left + endRect.width / 2 - canvasContainer.offsetLeft;
            const y2 = endRect.top + endRect.height / 2 - canvasContainer.offsetTop;
            
            conn.line.setAttribute('x1', x1);
            conn.line.setAttribute('y1', y1);
            conn.line.setAttribute('x2', x2);
            conn.line.setAttribute('y2', y2);
        });
    }

    // Handle mouse move on canvas
    canvasContainer.addEventListener('mousemove', function(e) {
        if (!drawingLine || !tempLine) return;
        
        const x = e.clientX - canvasContainer.offsetLeft;
        const y = e.clientY - canvasContainer.offsetTop;
        
        tempLine.setAttribute('x2', x);
        tempLine.setAttribute('y2', y);
    });

    // Handle mouse up on canvas
    canvasContainer.addEventListener('mouseup', function(e) {
        if (!drawingLine) return;
        
        const target = e.target;
        if (target.classList.contains('handle') && target !== selectedHandle) {
            const startHandle = selectedHandle;
            const endHandle = target;
            
            if ((startHandle.classList.contains('output') && endHandle.classList.contains('input')) ||
                (startHandle.classList.contains('input') && endHandle.classList.contains('output'))) {
                connections.push({
                    start: startHandle,
                    end: endHandle,
                    line: tempLine
                });
                updateConnections();
                tempLine = null;
            }
        }
        
        if (tempLine) {
            tempLine.remove();
            tempLine = null;
        }
        
        drawingLine = false;
        selectedHandle = null;
    });

    // Make toolbar items draggable
    document.querySelectorAll('.toolbar-item').forEach(item => {
        item.addEventListener('dragstart', function(e) {
            e.dataTransfer.setData('text/plain', item.dataset.type);
        });
        
        item.setAttribute('draggable', true);
    });

    // Handle drag and drop on canvas
    canvasContainer.addEventListener('dragover', function(e) {
        e.preventDefault();
    });

    canvasContainer.addEventListener('drop', function(e) {
        e.preventDefault();
        const type = e.dataTransfer.getData('text/plain');
        const x = e.clientX - canvasContainer.offsetLeft;
        const y = e.clientY - canvasContainer.offsetTop;
        createStepNode(type, x, y);
    });

    // Save journey
    document.getElementById('saveJourney').addEventListener('click', function() {
        const journeyData = {
            steps: steps.map(step => ({
                id: step.dataset.stepId,
                type: step.querySelector('.type').textContent,
                position: {
                    x: parseInt(step.style.left),
                    y: parseInt(step.style.top)
                }
            })),
            connections: connections.map(conn => ({
                from: conn.start.closest('.step-node').dataset.stepId,
                to: conn.end.closest('.step-node').dataset.stepId
            }))
        };

        // Send journey data to server
        fetch('/create_journey', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(journeyData)
        })
        .then(response => response.json())
        .then(data => {
            alert('Journey saved successfully!');
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Error saving journey');
        });
    });
});
</script>
{% endblock %}
